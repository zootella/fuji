




you've coded Thumbnail but haven't run it yet
to run it, make a test container which you drag a path into and it shows that image as a single thumbnail
there, you can also start to explore the css layout for the text like flow





confirm that at least you get 1:1 pixels on an old fashioned monitor
where the hdardware is not retina
and the os scale is 1


ok, so it's really ahrd to get the real resolution
but even if you had it, would it work?
so hard code in your real ersolution, which you know for this monitor
and fill the square with black and white stripes
and you think that it's going to look bad
and then you can abandon this trail
and if you really want true resolution using fuji, switch to 4k in settings

















so then there's the minimap
which is sorta theoretical
what if it's a single canvas you squash images into
like it's cropped squares
so you can see when color change
you click on an image on the minimap, and it pages up thumbnails that surround that image
it's not exact, not one to one, not a zoom out


so here's what the application looks like, the layout of the main view, windowed

toolbar
path box
tree, with prev and next buttons for next folder that has images <--really good idea
thumbnail contact sheet, no scroll, flip back and forward through folder boundaries
minimap, squashed squares, vibes
preview 


full screen is just the lightbox view, or just the thumbnail flipbook, only
when you make the window bigger you get more thumbnails, not bigger thumbnails
the first one stays first, more or less come in after, all the page numbers and contents change
js, not layout, must decide how many images go on each row, probably?

ok so this lean forward design never shows a scrollbar
there are no memory concerns
it is easy to know what it should load ahead, just getting image tags ready

think about what could happen as the user scrolls the scroll wheel over each of these areas
over the tree view, flips through the folders - and remember there's no scroll in the tree view!
over the contact sheet, flips through pages
doesn't do anything over the minimap column
over the preview, flips through the image, maybe







your js can count how many pixels we've asked the renderer to keep in memory
this is not the byte size of the images loaded
rather it's the number of rendered pixels
and then when that gets too big, it throws away some distant ones



you want full screen lightbox, of course
and also full screen contact sheet flipbook
there needs to be a subtle visual representation when you flip over the edge of a folder









ok but you forgot the prompt to try to make something useful to you in just a few sessions!
how about
[x]drag file into window, works from many paths and drives
[x]roll mouse wheel to flip forward and back in that folder, uses smart ordering
[x]zoom in and out of an image and drag it around in lightbox view
[x]fullscreen
[]contact sheet view, does scroll, constant height, no concerns on memory
at this point, no concerns on ui, settings, speed, or memory, or image fidelity
see how good it is when coded really simple










what if the flip plan were this
if the greatest dimension of the image is the same, the zoom and viewport is the same
if not, then it returns to default placement, which is
- small images are 2x zoom, centered
- large images are fit width or height, exactly

other tile sizing strategies you've thought of
- the traditional one, not going to do it, a grid of squares, rectangles sized smaller within those squares, terrible
- size rectangle into square so a gallery of pictures from the same camera, most landscape, one portrait, appear at the same scale (the flickr strategy scales the portrait one smaller)
- logarithmic resize so big images look big in the contact sheet
be able to switch between these in the same way you can switch the lightbox zoom mode






[h]elp - welcome and help message in center box, starts displayed
[i]nformation - details about image and load in bottom hud

[d]iamond - reset to center, size and zoom; turn off lock
[f]it - fit image on screen, no panning
[w]idth - fit to width, can pan up and down only
[1]...[9] - pixel zoom, based on true hardware panel pixels
[a]cdsee classic copy; put this one in there just so you can tweet at acdsystems

[l]ock pan - drag lock, now you don't have to click to pan around, idea from the DOS program from 1993
[g]amma - increase gamma in large steps, ok then how do you reset it
[p]ixelated - toggle on or off
[space] - turn on or off slideshow



standard and expressive controls to flip, zoom, and pan
gamers will have a mouse with a clicky wheel
limited users won't even have page up and page down
follow expected standards like Ctrl+ to zoom in
work well in a moment where the user wants to use only mouse, or only keyboard

add things like:
right drag up or down to zoom pixel by pixel
another drag up or down to adjust gamma really granular
pan with arrow keys, moving a quarter screen height distance



slideshow has a random option
which shuffles the contents of the folder
but then keeps that shuffled order, so you can flip back and forward
and then restart the automatic slideshow








grab and grabbing are a mac only thing, and look weird
ok so here's what you want
over the tabletop, pointer disappears when it falls to rest
during a drag, pointer is also off







ok, so the only reason to try to get the real resolution from rust is so you can code the 1234 zoom
and so you can sorta see how many pixels you're dealing with, here
you have to trust the os compositor that it will actually paint image pixels to hardware pixels, though
or, change the os looks like resolution to the hardware resolution when running tauri


also, for really small images, and images with the 1234 zoom
you probably want to style the img so that it doesn't stretch
so then here's a test you can do when things are coded this way
have a real pixel art image, like your test stripes, or some eboy something
and then with a scale or looks like resolution | with win1.0scale and mac natural resolution
in fuji do 4x zoom, by pressing 4, and then: linnen test for sharp pixels





crazy ideas section
what if right drag up and down is zoom
and left and right is gamma
so both are really really granular

hud popup show the zoom like
125%
gamma like
2.20Î³
no, not tied together, and yes tied to the mouse; and controlled just with vertical distance gained or lost
zoom is right click drag, or control left drag, or control mouse wheel
gamma is right or left drag, or mouse wheel, with shift pressed
L locks the pan, this returns to 1993 DOS mode, fuckyeah

also shortcut keys for reset
d - diamond, or r for reset
f - fit to screen, or s for fit to screen
w - fit to width, with 
123456 - that level of zoom, with coarse pixel sizing, also; all above are smooth default sizing
and those three are all left hand keys, which is great

will you need another one, [s]mart, which makes huge images reasonable and small images 2x raster in CSS pixels

panning dimensions and limitations are specific to the lightbox view mode
d lets you pan any way and away forever
w lets you pan up and down but not side to side
f has no panning at all
a lets you pan both directions, but not beyond the edge of the image
ok so then what happens when you zoom in?
probably it switches to d mode
either entirely (easiest, do first) or until the next flip








crazy ideas section
have late 90s web-style background options, like paper, marble
easy to do as you just use css to tile an image on the table
also do drop shadows that don't affect layout, for instance

and things like there's a single pixel focus glow line that appears as you move the mouse over controls and images
so you can click the moment you see the thing you want to click on highlighted
this is so so usable and so underused







but keep in mind that lightbox will only be fullscreen, so then there won't be 
really useful mvp has
[x]drag in an image, it goes fullscreen
[x]flick the wheel forward and ack through images
[x]zoom and pan
[x]esc or double click out of fullscreen to a window
[]scroll through a same size flow of all the images in that folder
[]double-click one to go back lightbox fullscreen and see it
and then after that you add
[]filename and path, anything to be able find it in the shell after looking at it in fuji
[]gamma
[]smart ordering, saved date with sequences grouped together and ordered properly










yeah, lots to figure out here
there are
(a) really small images, like windows icons from the 90s, png screenshots, stuff like that
(b) small images, like web thumbnails you couldn't find the bigger version of, or pictures from the 90s
(c) big images, like everything today

this is the idea that the diamond always persists, and that the image always touches the edges of the diamond
yeah, lean on good controls to let the user drive, rather than complex rules to deal with transitions; there are too many previous image to next image transitions possible!!

now if the user presses w for width, now there isn't a diamond at all
instead, every image is fit to full width, and scrolling can only move up and down
this is commic book page mode

oh at the start make p pixelated a manual toggle
because you don't know when you're going to want it on or off
yeah, probably always do that










Ctrl+C - copy the path to the current image

oh, what if you automatically turn on pixelated when the zoom is bigger than something
so you can have a large dimension screenshot, and ctrl+wheel zoom all the way in
and instead of getting those grayscale pyramids, it naturally switches to pixelated

ok, sure, does that rule widely applied solve other problems
like, let's say you always fit the image, any size, to the diamond
and the diamond, of course, persists through wheel flips



but with all this hud and popups, also remember to make Fuji immersive
let the user exist entirely within the codex of images, without being distracted by information in text at all







in the crazy ideas section, the zoom world tabletop, where you pan from one image to the next
it's as though there are always 8 images around the center one, or something
this is a really cool idea







<style scoped>
.myTable {
	will-change: transform; /* pan with the compositor thread; no layout or paint; buttery-smooth ðŸ§ˆ */
	touch-action: none; /* tell the browser to not try to scroll or zoom behind a drag that we are handling */
}
.myHud {
	pointer-events: none; /* the HUD is information, only--no buttons, no selectable text */
}
</style>






so then what do you do if the flip commands come in faster than the animation frames?
1 ignore a click when we're already about to do a flip
2 skip and image to keep up
3 queue each click and flip as fast as the frames afterwards
just ignore them, duh; this won't actually happen






earlier you were permutating all the possible next images
previous/next
zoom in/out
gamma brighter/dimmer
and you thought maybe there's another one?
but now zoom is CSS, and gamma is SVG
so really it's previous and next

for the disk -> data url string; you can just keep the string around (you could make a pretty complex application cache of these, actually!) or just keep the previous one around
and so then it's just about next/previous image










oh have a bauhaus theme where the file name is the caption in large light gray helvetica
crazy ideas section








note on full set of layouts:
so you're going to plan the arrows for diamond layout on the drafting table,
focused on diamond layout now, but looking ahead on paper and pencil towards the whole set:
- [d]iamond layout, next image fits into same invisible diamond, zoom and pan move the diamond; pan X and Y
- size to [f]it layout, next image also fits to screen; no pan at all
- fit [w]idth only, next image also fits width; pan Y only
- zoom [1,2,3,4,5,6,7,8,9]x, next image same space origin but totally different size on screen; pan X and Y
any zoom in or out on any of those switches to diamond layout







i think there is no zoom
there is a diamond, which starts at screen sum and then goes up and down with +/-
and there is a shown, which is output, comparing card2, natural, panel, and screen

next feature to code with this refactored setup:
[]info includes shown percent output number
[]zoom keeps part of image in the center of the frame in the center
building towards a system of modes that control how pan, zoom, and flip behave:
d(iamond), f(it), w(idth), 123456789(x panel pixels)






fuji
search the web for tiled background, like marble, hardwood floors
play around with svg to make some, like carbon fiber







//you probably don't need this anymore, but it's cool
export const hardVerticals = [
	480,  // Legacy 640Ã—480 VGA; still seen in embedded systems and some virtual modes
	600,  // SVGA (800Ã—600); common in late '90s multimedia PCs
	720,  // HD (1280Ã—720); entry-level TVs, older budget laptops
	768,  // WXGA (1366Ã—768); dominant in budget laptops for over a decade [mainstream]
	864,  // FWXGA variant (1536Ã—864); occasional in mid-range laptops
	900,  // 1440Ã—900 / 1600Ã—900; mid-range panels, especially Dell and HP [mainstream]
	1024, // SXGA (1280Ã—1024); popular 4:3 office monitors in the 2000s
	1050, // WSXGA+ (1680Ã—1050); mid-to-high-end 16:10 panels in the late 2000s
	1080, // Full HD (1920Ã—1080); the most common resolution today [mainstream]
	1152, // QWXGA (2048Ã—1152); uncommon wide format, some niche monitors
	1200, // UXGA (1600Ã—1200) / WUXGA (1920Ã—1200); pro and workstation panels [mainstream]
	1440, // QHD (2560Ã—1440); high-end monitors, gaming setups, premium laptops [mainstream]
	1536, // QXGA (2048Ã—1536); uncommon high-res 4:3, some tablets
	1600, // WQXGA (2560Ã—1600); premium 16:10 laptops and monitors [mainstream]
	1664, // MacBook Air M2 native (2560Ã—1664)
	1964, // MacBook Pro 14" native (3024Ã—1964)
	2160, // 4K UHD (3840Ã—2160); widespread in premium laptops and monitors [mainstream]
	2234, // MacBook Pro 16" native (3456Ã—2234)
	2520, // iMac 24" 4.5K Retina (4480Ã—2520)
	2880, // 5K (5120Ã—2880); iMacs and ultra-premium displays
	3200, // 6K (6016Ã—3384); Apple Pro Display XDR and similar
	4320, // 8K UHD (7680Ã—4320); bleeding-edge professional monitors
]





sorts
- name, matching the behavior on windows explorer and macos finder
- date, using the saved date, which is not the authored nor modified nor accessed date; find some that a browser saved using the date from the server
- smart, your idea where it's by date with tiebrakers for numbered sets, this is cool, this is one of the brochure features, actually
- shuffled, not the same as random


fuji brochure features
- viewport persistance
- thumbnails in flow
- smart sort





fuji
a random slideshow
you start and pause with spacebar
you can move forward and back, the order is shuffled and infinite, but stays as a queue in memory
yeah, these are two really good improvements
maybe you start the slideshow with ctrl+s, and then get options like order is random, alphabet, date, smart, and how many full seconds



fuji
disappear pointer thing





code fuji
copilot says yeah, it makes sense to write some code to
detect a legacy setup where all the pixel units are the same, pixels are real
and there and only there
Math.round the numbers you hand css
so, do this in how you calculate quiverB from quiverA, of course
and quiverA should have a boolean, cssPixelsAreReal






