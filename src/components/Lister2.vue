<script setup>//./components/Lister2.vue - getting functionality ready for mvpersonal use

import {ref, onMounted, onBeforeUnmount, nextTick} from 'vue'
import {getCurrentWindow} from '@tauri-apps/api/window'
import {ioRead, ioReadDir} from '../io.js'
import parse from 'path-browserify'//naming this parse instead of path so we can have variables named path

const refLines = ref([])

function log(msg) {
	refLines.value.push(msg)
}

onMounted(async () => {
	const w = getCurrentWindow()
	unlistenFileDrop = await w.onDragDropEvent(async (event) => {
		if (event.payload.type == 'drop' && event.payload.paths.length) {
			let path = forwardize(event.payload.paths[0])

			await lookPath(path)
		}
	})
})
let unlistenFileDrop//will hold the unsubscribe function set above and called below
onBeforeUnmount(() => {
	if (unlistenFileDrop) unlistenFileDrop()
})

//forwardize all new paths that come into the system, then backize to show on the page
function forwardize(path) {
	//rotate backslashes forward given what looks like a windows drive letter path; the forwardized path will still work with path-browserify and our rust io module code
	return /^[a-zA-Z]:[\\/]/.test(path) ? path.replace(/\\/g, '/') : path
}
function backize(path) {
	//but will look weird on windows, so use this in template code before showing to a Windows user
	return /^[a-zA-Z]:[\\/]/.test(path) ? path.replace(/\//g, '\\') : path
}

async function listImages(path) {//given a path to a folder, return a sorted list of complete paths to all the images

	/*
	ok chat, let's write this
	i ithink the array from ioReadDir we'll
	- just look at is_file true items
	- use browserify-path, here named parse, to get the file extension
	- and also to assemble the complete path
	- have a hardcoded whitelist of common image file extensions (for this, i'd like y ou to think deeply, seraching as necessary. let's consider computing since the start of the web, windows mac and unix, to list )
	*/

}

async function lookPath(path) {//given a path, return text all about it

	let folder = parse.dirname(path)
	let raw = await ioReadDir(folder)
	console.log(raw)

	/*
	rudimentary here is .name "1red.jpg", .is_file true
	*/

	log(`${path} <- path, backized to ${backize(path)}
${folder} <- folder, backized to ${backize(folder)}
`)









	/*
	let s = ``
	try {

		let i = await stat(p)
		s += `\n${p}`
		if (i.isDirectory) s += ' üóÇÔ∏è'
		if (i.isFile) s += ' üìë'
		s += ` <${i.size}>`

		if (i.isDirectory) {

			let entries = await readDir(p)
			s += ` and contains ${entries.length}`

			if (descend) {
				for (let entry of entries) {
					let q = path.join(p, entry.name)
					s += await lookPath(q, false)
				}
			}
		}
	} catch (e) {
		s += `\n‚ö†Ô∏è caught exception "${e}" looking at path "${p}" ‚ö†Ô∏è`
	}
	return s
	*/

}
/*
findings on mac:
home folder and below, can see files, but get exceptions trying to stat .DS_Store and .localized
dragging in a file from drive k works, but then you can't do the listing around it

dropped in path "/Users/kevin/Documents/folder1/7187Gc5WBwL.jpg"...

/Users/kevin/Documents/folder1 üóÇÔ∏è <192> and contains 4
/Users/kevin/Documents/folder1/cat.jpg üìë <427319>
/Users/kevin/Documents/folder1/fuji.png üìë <17501>
/Users/kevin/Documents/folder1/7187Gc5WBwL.jpg üìë <195706>
/Users/kevin/Documents/folder1/fuji.svg üìë <162>

dropped in path "/Volumes/DriveK/folder1/folder2/cat.jpg"...

‚ö†Ô∏è caught exception "forbidden path: /Volumes/DriveK/folder1/folder2" looking at path "/Volumes/DriveK/folder1/folder2" ‚ö†Ô∏è

so, more fiddling with permissions will be necessary
but this enough of a proof of concept to move on to neighboring functionality tests



also, if you need to drop down to Rust to get plugin-fs to allow more paths
maybe just write all your own I/O io in Rust,
as there might be more plugin-fs limitations after this one
and as there aren't really many different things you need to do with I/O



*/

</script>
<template>

<div class="h-full overflow-y-auto bg-white p-4 font-mono text-xs leading-tight">
<div v-for="(line, idx) in refLines" :key="idx"><pre>{{line}}</pre></div>
</div>

</template>
<style scoped>

</style>
