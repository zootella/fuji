





onMounted(() => {

	//register listeners for input devices that are not related to position; those will go on the table in the template
	window.addEventListener('keydown', onKey)
	frameRef.value.addEventListener('wheel', onWheel, {passive: false})

	cardRef.value.style.transformOrigin = '0 0'
	cardRef.value.style.transform = `translate(${spacePosition.x}px, ${spacePosition.y}px)`
})
onBeforeUnmount(() => {

	//remove the listeners; there shouldn't be a danglign pointer but release one if there is
	window.removeEventListener('keydown', onKey)
	frameRef.value.removeEventListener('wheel', onWheel)
	if (drag?.pointer) { cardRef.value.releasePointerCapture(drag.pointer); drag.pointer = null }
})








let arrow1 = {x: 0, y: 0}//arrow1 points from the corner of the frame to the center of the pannable space; changes when the user drags to pan
let arrow2 = {x: 0, y: 0}//arrow2 points from the center of the pannable space to corner of the card; changes when we zoom
/*
planning new design:

arrow1 from frame corner to frame center
arrow2 from frame center to space center
arrow3 from space center to card far corner

sorted that way:
- a window resize changes only arrow1
- a pan changes only arrow2
- a zoom changes only arrow3
- a flip changes only arrow3

there's a single function which affects the page:
- compute the card transform x and y from arrow1 and arrow2
- compute the card width and height from arrow1, arrow2, and arrow3
there isn't complex triangle subtraction arrow math

a single do it function leads to this code:

	cardRef.value.style.transform = `translate(${a12.x}px, ${a12.y}px)`
	cardRef.value.style.width  = `${a12.w}px`
	cardRef.value.style.height = `${a12.h}px`

performance note:
chat says there may be a benefit to putting these in request animatiion frame
and also may be a benefit in caching last set values and writing our own code here to only do the transform
or only the width and height, if necessary
chat also says the width and height may be harder on the GPU than the transform
but before you optimize all that, you'll have to get to the point where you've
- read ahead the next image for a flip, and
- delayed the flip until the next image is ready
with zero black frames, that whole issue

note on full set of layouts:
so you're going to plan the arrows for diamond layout on the drafting table,
focused on diamond layout now, but looking ahead on paper and pencil towards the whole set:
- [d]iamond layout, next image fits into same invisible diamond, zoom and pan move the diamond; pan X and Y
- size to [f]it layout, next image also fits to screen; no pan at all
- fit [w]idth only, next image also fits width; pan Y only
- zoom [1,2,3,4,5,6,7,8,9]x, next image same space origin but totally different size on screen; pan X and Y
any zoom in or out on any of those switches to diamond layout
*/














/*
[]zoom with mouse wheel
[]hud
[]marble tile
[]shadows on image
[~]continuity with window move, resize, fullscreen; do that last (and, of course, you do it first. and, of course, it doesn't work and takes most of the middle of the day)


*/











	//todo

	/*
	let m = arrowFrameMiddle()//m points from frame corner to frame middle
	let a12 = arrowMath(arrow1, '+', arrow2)//a12 points from frame corner to card corner

	//calculate the arrows which will grow or shrink with this zoom, all pointing from the frame center
	let f1 = arrowMath(arrow1, '-', m)//f1 points from frame center to card center
	let f2 = arrowMath(a12,    '-', m)//f2 points from frame center to card corner

	console.log(zoomAmount)

	//zoom them
	f1 = arrowMath(f1, '*', zoomAmount)
	f2 = arrowMath(f2, '*', zoomAmount)

	//calculate new arrows 1 and 2, and new card with and height
	arrow1 = arrowMath(m,  '+', f1)
	arrow2 = arrowMath(f2, '-', f1)
	a12 = arrowMath(arrow1, '+', arrow2)
	a12.w = -2*arrow2.x
	a12.h = -2*arrow2.y

	cardRef.value.style.transform = `translate(${a12.x}px, ${a12.y}px)`
	cardRef.value.style.width  = `${a12.w}px`
	cardRef.value.style.height = `${a12.h}px`
	*/



/*
function arrowCardCorner() {//based on the image dimensions and zoom amount, points from the card center to corner
	return {
		x: ,
		y: 
	}
}
function arrowFrameMiddle() {//based on how big the window is right now, get the arrow from the frame corner to the frame middle
	return {
		x: frameRef.value.clientWidth  / 2,
		y: frameRef.value.clientHeight / 2
	}
}
*/














